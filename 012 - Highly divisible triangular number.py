"""
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be
1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
"""
"""
TO SLOW!
"""

import math

def triange_numer_gen():
    """
    This function generates triangle numbers
    """
    next_triange = 1
    next_number = 2

    while True:
        yield next_triange
        next_triange += next_number
        next_number += 1


def factorial(n):
    if n <= 1:
        return 1
    else:
        return n * factorial(n - 1)


def factorial_with_stop(n, k):
    if n <= k:
        return 1
    else:
        return n * factorial_with_stop(n - 1, k)


def combinations(n, k):
    if n - k > k:
        return factorial_with_stop(n, n - k) // factorial(k)
    else:
        return factorial_with_stop(n, k) // factorial(n - k)

#print(combinations(4,2))

def find_number_of_divisors(num):
    """
    Finds the first number with "num" amount of divisors.
    """
    """
    This works but it is way to slow, I will come back to this later when I have more ideas.
    """
    prime_list = [2]

    for number in triange_numer_gen():
        total = 1

        while number > prime_list[-1]:
            prime_list.append(find_next_prime(prime_list))

        temp_num = number
        index = 0

        while temp_num != 1:
            divisor_num = 1
            devided = temp_num
            b = True
            while b:
                devided = devided / prime_list[index]
                if int(devided) == devided:
                    divisor_num += 1
                    temp_num = int(devided)
                else:
                    b = False

            total = total * divisor_num
            index += 1

        if total >= num:
            return number


def is_prime(num, list_smaler_primes):
    """
    Checks if the number is_prime using previous primes
    """
    sqrt = math.sqrt(num)
    for i in list_smaler_primes:
        if i > sqrt:
            break
        if num%i == 0:
            return False
    return True


def find_next_prime(prime_list):
    """
    Finds the next prime number using a list of all the previous ones and return it
    """
    start = prime_list[-1]

    while True:
        start += 1
        if is_prime(start, prime_list):
            return start


#print(find_number_of_divisors(500))


def find_number_of_divisors2():
    """
    built on the knowledge that the number will be built by some combination of 2,3 and 5 because
    any prime beyond 5 will make the number larger than a combination of the 3 named.
    Also the fact that the number of divisors are the number of each prime factor + 1 multiplied by the
    same thing for the other prime factors
    """
    """
    Realised that this does not find the first triangular number that is divisible by 500 different numbers
    it finds the FIRST number to be divisible by the 500 different numbers.
    """

print(find_number_of_divisors2())